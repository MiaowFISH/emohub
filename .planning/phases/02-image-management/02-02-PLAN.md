---
phase: 02-image-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/index.html
  - apps/web/vite.config.ts
  - apps/web/tsconfig.json
  - apps/web/src/main.tsx
  - apps/web/src/routeTree.gen.ts
  - apps/web/src/routes/__root.tsx
  - apps/web/src/routes/index.tsx
  - apps/web/src/lib/api.ts
  - apps/web/src/stores/imageStore.ts
autonomous: true

must_haves:
  truths:
    - "Web app builds and serves via Vite dev server"
    - "TanStack Router renders a root layout with child routes"
    - "Zustand image store manages image list state with fetch, add, remove actions"
    - "API client module provides typed fetch wrappers for all image endpoints"
  artifacts:
    - path: "apps/web/vite.config.ts"
      provides: "Vite config with React plugin and API proxy to server"
    - path: "apps/web/src/routes/__root.tsx"
      provides: "Root layout with app shell (header, main content area)"
    - path: "apps/web/src/routes/index.tsx"
      provides: "Home page route (placeholder for image grid)"
    - path: "apps/web/src/lib/api.ts"
      provides: "Typed API client for image endpoints"
      exports: ["imageApi"]
    - path: "apps/web/src/stores/imageStore.ts"
      provides: "Zustand store for image state management"
      exports: ["useImageStore"]
  key_links:
    - from: "apps/web/src/stores/imageStore.ts"
      to: "apps/web/src/lib/api.ts"
      via: "import and call API functions"
      pattern: "import.*api"
    - from: "apps/web/vite.config.ts"
      to: "http://localhost:3000"
      via: "Vite proxy for /api requests"
      pattern: "proxy.*api"
---

<objective>
Set up the web application foundation: Vite build, TanStack Router, app layout shell, API client, and Zustand image store.

Purpose: Provides the frontend scaffolding that all UI features (upload, grid, lightbox, delete) will build on top of.
Output: A running web app with routing, state management, and API integration ready for feature components.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-image-management/02-RESEARCH.md
@apps/web/package.json
@packages/shared/src/image.ts
@packages/shared/src/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Vite config, TanStack Router setup, and app shell</name>
  <files>
    apps/web/package.json
    apps/web/index.html
    apps/web/vite.config.ts
    apps/web/tsconfig.json
    apps/web/src/main.tsx
    apps/web/src/routeTree.gen.ts
    apps/web/src/routes/__root.tsx
    apps/web/src/routes/index.tsx
  </files>
  <action>
Update `apps/web/package.json`:
- Add "type": "module"
- Add scripts: "dev": "vite", "build": "tsc -b && vite build", "preview": "vite preview"
- Add dependencies: "@emohub/shared": "workspace:*"
- Add devDependencies: "vite": "^6.3.5", "typescript": "^5.8.3", "@tanstack/router-plugin": "^1.159.5", "@types/react": "^19.2.4", "@types/react-dom": "^19.2.4"

Create `apps/web/tsconfig.json`:
- compilerOptions: target ES2022, module ESNext, moduleResolution bundler, jsx react-jsx, strict true, esModuleInterop true, skipLibCheck true, paths: { "@/*": ["./src/*"] }
- include: ["src"]

Create `apps/web/vite.config.ts`:
- Import react plugin from @vitejs/plugin-react
- Import TanStackRouterVite from @tanstack/router-plugin/vite
- Plugins: [TanStackRouterVite(), react()]
- Resolve alias: "@" -> "./src"
- Server proxy: "/api" -> "http://localhost:3000" (for dev)

Create `apps/web/index.html`:
- Standard HTML5 boilerplate with div#root
- Script tag pointing to /src/main.tsx
- Title: "EmoHub"

Create `apps/web/src/main.tsx`:
- Import React, ReactDOM
- Import { RouterProvider, createRouter } from '@tanstack/react-router'
- Import { routeTree } from './routeTree.gen'
- Create router with routeTree
- Render RouterProvider into #root using createRoot

Create `apps/web/src/routeTree.gen.ts`:
- This file is auto-generated by TanStack Router plugin. Create a minimal valid version that imports __root and index routes and builds the route tree. The plugin will regenerate it on dev server start.

Create `apps/web/src/routes/__root.tsx`:
- Import { createRootRoute, Outlet } from '@tanstack/react-router'
- Export root route with component: RootLayout
- RootLayout: a simple app shell with a header containing "EmoHub" title, and a main content area rendering <Outlet />
- Use basic CSS (inline styles or a minimal CSS file) — keep it simple, just enough structure for content to render properly. Flexbox column layout, full viewport height.

Create `apps/web/src/routes/index.tsx`:
- Import { createFileRoute } from '@tanstack/react-router'
- Export index route with component: HomePage
- HomePage: placeholder div with text "Images will appear here" — this will be replaced by ImageGrid in Plan 03.

Run `cd /opt/.openclaw/workspace/external/emohub && bun install` to link workspace dependencies.
  </action>
  <verify>
`cd /opt/.openclaw/workspace/external/emohub/apps/web && bunx vite build` completes without errors. All files exist.
  </verify>
  <done>Web app builds successfully. TanStack Router renders root layout with index route. Vite proxies /api to server.</done>
</task>

<task type="auto">
  <name>Task 2: API client and Zustand image store</name>
  <files>
    apps/web/src/lib/api.ts
    apps/web/src/stores/imageStore.ts
  </files>
  <action>
Create `apps/web/src/lib/api.ts`:
- Import types from @emohub/shared: Image, ApiResponse, PaginatedResponse
- Define base URL as empty string (Vite proxy handles /api prefix)
- `imageApi` object with methods:
  - `list(page = 1, limit = 50): Promise<PaginatedResponse<Image>>` — GET /api/images?page=N&limit=N
  - `upload(files: File[]): Promise<ApiResponse<Array<{ filename: string; duplicate: boolean; id: string; image: Image }>>>` — POST /api/images/upload with FormData, append each file under field name "file"
  - `getThumbnailUrl(id: string): string` — returns "/api/images/{id}/thumbnail"
  - `getFullUrl(id: string): string` — returns "/api/images/{id}/full"
  - `delete(id: string): Promise<ApiResponse<Image>>` — DELETE /api/images/{id}
  - `deleteBatch(ids: string[]): Promise<ApiResponse<unknown>>` — DELETE /api/images/batch with JSON body { ids }
  - `convertToGif(id: string): Promise<Blob>` — POST /api/images/{id}/convert-gif, returns response.blob()
- All fetch calls include proper error handling: check response.ok, throw on failure with error message from response body.

Create `apps/web/src/stores/imageStore.ts`:
- Import { create } from 'zustand'
- Import Image type from @emohub/shared
- Import { imageApi } from '@/lib/api'
- Interface ImageState:
  - images: Image[]
  - total: number
  - page: number
  - isLoading: boolean
  - selectedIds: Set<string>
  - fetchImages: (page?: number) => Promise<void>
  - addImages: (images: Image[]) => void
  - removeImages: (ids: string[]) => void
  - toggleSelect: (id: string) => void
  - selectAll: () => void
  - clearSelection: () => void
- Implement store:
  - fetchImages: set isLoading true, call imageApi.list, set images/total/page, set isLoading false. On error, set isLoading false and log error.
  - addImages: prepend new images to existing list, increment total
  - removeImages: filter out by ids, decrement total, remove from selectedIds
  - toggleSelect: add/remove id from selectedIds Set (create new Set for immutability)
  - selectAll: set selectedIds to Set of all image ids
  - clearSelection: set selectedIds to empty Set
  </action>
  <verify>
`cd /opt/.openclaw/workspace/external/emohub/apps/web && bunx vite build` still passes. Files exist and export imageApi and useImageStore.
  </verify>
  <done>API client provides typed wrappers for all image endpoints. Zustand store manages image list, loading state, and selection with immutable updates.</done>
</task>

</tasks>

<verification>
- `bunx vite build` in apps/web succeeds
- Web app renders root layout with "EmoHub" header and index page
- Vite config proxies /api to localhost:3000
- imageApi exports all endpoint methods with proper types
- useImageStore exports store with fetchImages, addImages, removeImages, selection methods
</verification>

<success_criteria>
Web application foundation is complete: builds, routes work, API client is typed and ready, state management handles image list and selection. Ready for feature components in Plan 03.
</success_criteria>

<output>
After completion, create `.planning/phases/02-image-management/02-02-SUMMARY.md`
</output>
