---
phase: 03-tag-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/tag.ts
  - packages/server/src/services/tagService.ts
  - packages/server/src/routes/tags.ts
  - packages/server/src/app.ts
  - packages/server/src/routes/images.ts
  - packages/server/src/services/imageService.ts
  - apps/web/src/lib/api.ts
  - apps/web/src/stores/tagStore.ts
autonomous: true

must_haves:
  truths:
    - "Tag CRUD API endpoints respond correctly (create, list, rename, delete)"
    - "Image list API returns tags included with each image"
    - "Batch tag add/remove API works for multiple images and tags"
    - "Frontend tag store fetches and caches tag list"
    - "Frontend API client can call all tag endpoints"
  artifacts:
    - path: "packages/server/src/services/tagService.ts"
      provides: "Tag business logic (CRUD, batch operations, filtering)"
      exports: ["createTag", "listTags", "renameTag", "deleteTag", "batchAddTags", "batchRemoveTags", "getImageTags"]
    - path: "packages/server/src/routes/tags.ts"
      provides: "Tag REST API routes"
    - path: "apps/web/src/stores/tagStore.ts"
      provides: "Tag state management"
    - path: "apps/web/src/lib/api.ts"
      provides: "Tag API client functions"
      contains: "tagApi"
  key_links:
    - from: "packages/server/src/routes/tags.ts"
      to: "packages/server/src/services/tagService.ts"
      via: "service function calls"
      pattern: "tagService\\."
    - from: "packages/server/src/app.ts"
      to: "packages/server/src/routes/tags.ts"
      via: "fastify.register(tagRoutes)"
      pattern: "register.*tagRoutes"
    - from: "apps/web/src/stores/tagStore.ts"
      to: "apps/web/src/lib/api.ts"
      via: "tagApi calls"
      pattern: "tagApi\\."
    - from: "packages/server/src/routes/images.ts"
      to: "prisma.image.findMany"
      via: "include tags in image list query"
      pattern: "include.*tags"
---

<objective>
Build the complete tag backend (service + API routes) and frontend foundation (API client + Zustand store) that all tag UI features depend on.

Purpose: Every tag feature (single-image tagging, filtering, batch operations, tag management) needs these endpoints and state management. Building them first as a foundation enables parallel UI work in subsequent plans.

Output: Working tag CRUD API at /api/tags, image list API enhanced with tag data, frontend tagApi client and tagStore ready for UI consumption.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-tag-system/03-RESEARCH.md
@packages/shared/src/tag.ts
@packages/shared/src/image.ts
@packages/shared/src/api.ts
@packages/server/src/app.ts
@packages/server/src/services/imageService.ts
@packages/server/src/routes/images.ts
@apps/web/src/lib/api.ts
@apps/web/src/stores/imageStore.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tag service, API routes, and image list enhancement</name>
  <files>
    packages/shared/src/tag.ts
    packages/server/src/services/tagService.ts
    packages/server/src/routes/tags.ts
    packages/server/src/app.ts
    packages/server/src/routes/images.ts
    packages/server/src/services/imageService.ts
  </files>
  <action>
1. Extend `packages/shared/src/tag.ts` with additional types needed by the API:
   - `TagWithCount` interface: extends Tag with `imageCount: number` (for showing usage count in UI)
   - `BatchTagInput` interface: `{ imageIds: string[], tagIds: string[] }`
   - Keep existing `Tag`, `CreateTagInput`, `TagCategory` as-is

2. Create `packages/server/src/services/tagService.ts`:
   - `createTag(prisma, input: { name: string, category?: string })`: Normalize name to lowercase trim, upsert to handle duplicates gracefully. Return the tag.
   - `listTags(prisma, search?: string)`: List all tags with image count. Use `prisma.tag.findMany` with `_count: { images: true }`. If search provided, filter with `contains` + `mode: 'insensitive'`. Order by name. Limit to 100 results.
   - `renameTag(prisma, id: string, newName: string)`: Normalize newName, check for name conflict, update. Throw if tag not found or name already taken.
   - `deleteTag(prisma, id: string)`: Delete tag (cascade handles ImageTag cleanup). Throw if not found.
   - `getImageTags(prisma, imageId: string)`: Return tags for a specific image via ImageTag join.
   - `batchAddTags(prisma, imageIds: string[], tagIds: string[])`: Use `prisma.imageTag.createMany` with `skipDuplicates: true` inside a transaction. Generate all imageId x tagId combinations.
   - `batchRemoveTags(prisma, imageIds: string[], tagIds: string[])`: Use `prisma.imageTag.deleteMany` with `imageId: { in: imageIds }, tagId: { in: tagIds }`.

3. Create `packages/server/src/routes/tags.ts` as FastifyPluginAsync:
   - `GET /` — List tags (optional `?search=` query param). Returns `{ success: true, data: TagWithCount[] }`.
   - `POST /` — Create tag. Body: `{ name: string, category?: string }`. Returns 201 with created tag.
   - `PUT /:id` — Rename tag. Body: `{ name: string }`. Returns updated tag.
   - `DELETE /:id` — Delete tag. Returns deleted tag.
   - `POST /batch/add` — Batch add tags to images. Body: `{ imageIds: string[], tagIds: string[] }`. Returns `{ success: true }`.
   - `POST /batch/remove` — Batch remove tags from images. Body: `{ imageIds: string[], tagIds: string[] }`. Returns `{ success: true }`.
   - `GET /image/:imageId` — Get tags for a specific image. Returns `{ success: true, data: Tag[] }`.
   - Proper error handling: 400 for validation errors, 404 for not found, 409 for name conflicts.

4. Register tag routes in `packages/server/src/app.ts`:
   - Import tagRoutes from `./routes/tags.js`
   - Register with prefix `/api/tags`

5. Modify `packages/server/src/services/imageService.ts` `listImages` function:
   - Add `include: { tags: { include: { tag: true } } }` to the findMany query
   - Map the result to flatten tags: `image.tags.map(it => ({ id: it.tag.id, name: it.tag.name, category: it.tag.category }))`
   - Add optional `tagIds?: string[]` parameter. When provided, add `where: { tags: { some: { tagId: { in: tagIds } } } }` for filtering.
   - Update the count query to use the same where clause when tagIds provided.

6. Modify `packages/server/src/routes/images.ts` GET `/` handler:
   - Parse `tagIds` from query string (comma-separated string → string array, or absent)
   - Pass tagIds to `imageService.listImages`
  </action>
  <verify>
Run `cd /opt/.openclaw/workspace/external/emohub && bun run --filter @emohub/server build` (or `npx tsc --noEmit` in server package) to verify TypeScript compiles. Then start the server and test:
- `curl http://localhost:3000/api/tags` returns empty array
- `curl -X POST http://localhost:3000/api/tags -H 'Content-Type: application/json' -d '{"name":"test"}' ` returns created tag
- `curl http://localhost:3000/api/tags` returns tag with imageCount
- `curl http://localhost:3000/api/images` returns images with tags array
  </verify>
  <done>Tag CRUD endpoints work (create, list, rename, delete). Batch add/remove endpoints accept imageIds + tagIds. Image list endpoint includes tags and supports tagIds filter parameter. All TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Frontend tag API client and Zustand store</name>
  <files>
    apps/web/src/lib/api.ts
    apps/web/src/stores/tagStore.ts
    apps/web/src/stores/imageStore.ts
  </files>
  <action>
1. Add `tagApi` object to `apps/web/src/lib/api.ts` (alongside existing `imageApi`):
   - `list(search?: string)`: GET `/api/tags` with optional `?search=` param. Returns `ApiResponse<TagWithCount[]>`.
   - `create(name: string, category?: string)`: POST `/api/tags`. Returns `ApiResponse<Tag>`.
   - `rename(id: string, name: string)`: PUT `/api/tags/${id}`. Returns `ApiResponse<Tag>`.
   - `delete(id: string)`: DELETE `/api/tags/${id}`. Returns `ApiResponse<Tag>`.
   - `batchAdd(imageIds: string[], tagIds: string[])`: POST `/api/tags/batch/add`. Returns `ApiResponse<void>`.
   - `batchRemove(imageIds: string[], tagIds: string[])`: POST `/api/tags/batch/remove`. Returns `ApiResponse<void>`.
   - `getImageTags(imageId: string)`: GET `/api/tags/image/${imageId}`. Returns `ApiResponse<Tag[]>`.
   - Import `Tag` and `TagWithCount` from `@emohub/shared`.

2. Create `apps/web/src/stores/tagStore.ts` using Zustand (follow imageStore pattern):
   - State: `tags: TagWithCount[]`, `isLoading: boolean`, `filterTagIds: Set<string>` (selected filter tags)
   - Actions:
     - `fetchTags(search?: string)`: Call `tagApi.list(search)`, set tags from response.data
     - `createTag(name: string, category?: string)`: Call `tagApi.create`, prepend to tags list, return created tag
     - `renameTag(id: string, name: string)`: Call `tagApi.rename`, update tag in list immutably
     - `deleteTag(id: string)`: Call `tagApi.delete`, remove from list
     - `toggleFilterTag(tagId: string)`: Toggle tagId in filterTagIds Set (immutable new Set)
     - `clearFilters()`: Reset filterTagIds to empty Set
   - Export `useTagStore` hook

3. Modify `apps/web/src/stores/imageStore.ts`:
   - Update `fetchImages` to accept optional `tagIds?: string[]` parameter
   - When tagIds provided, append `&tagIds=${tagIds.join(',')}` to the API URL
   - Update the `imageApi.list` call signature to pass tagIds through
   - Update `imageApi.list` in api.ts to accept optional `tagIds?: string[]` and append to query string

4. Import `TagWithCount` in api.ts — add it to shared/tag.ts exports if not already there.
  </action>
  <verify>
Run `cd /opt/.openclaw/workspace/external/emohub/apps/web && npx tsc --noEmit` to verify TypeScript compiles. Check that tagStore exports are correct and api.ts has no type errors.
  </verify>
  <done>Frontend tagApi client has all CRUD + batch methods. tagStore manages tag list, loading state, and filter selection. imageStore.fetchImages accepts tagIds for filtered queries. All TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. Server starts without errors: `cd packages/server && bun run dev`
2. Tag CRUD works via curl: create, list (with count), rename, delete
3. Batch operations work: add tags to images, remove tags from images
4. Image list includes tags: `GET /api/images` returns images with tags array
5. Image filtering works: `GET /api/images?tagIds=id1,id2` returns filtered results
6. Frontend TypeScript compiles: `cd apps/web && npx tsc --noEmit`
7. Tag store initializes and can fetch tags
</verification>

<success_criteria>
- All tag API endpoints respond with correct status codes and data shapes
- Image list API includes tag data and supports tag-based filtering
- Frontend API client and store are type-safe and ready for UI consumption
- No TypeScript compilation errors in either package
</success_criteria>

<output>
After completion, create `.planning/phases/03-tag-system/03-01-SUMMARY.md`
</output>
